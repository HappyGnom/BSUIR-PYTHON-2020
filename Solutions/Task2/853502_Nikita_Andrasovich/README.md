Лабораторная работа №2
======================

Выполнена с использование _Python 3.8.0_ на ОС _Linux KDE Neon_

## Структура программного пакета
Лабораторная разбита по папкам, в каждой из которых содержатся следующие элементы:
- Основной файл с функциями и/или классами, которые требовалось реализовать по заданию
- Файл _tests.py_, который содержит тесты для соответствующего задания
- Файл _demo.py_, в котором проводится демонстрация выполненного задания

Тесты написаны с использованием модуля 'unittest', покрытие проверено с использованем модуля _coverage_

Каждое задание можно проверять в скрипте demo.py.
Он исполняется следующим образом:
1.  Проводит все тесты
2.  Если все тесты выполнены успешно, то выполняется демонстрация работы программы

Также в корневой директории имеется скрипт setup.py, который позволяет установить все программы 
выполнив команду `python setup.py install --user`

## Описание программ

### Сортировка слиянием во внешней памяти
Выполнена с использованием модуля _tempfile_. Сортировка проводится по стандартному алгоритму сортировки слиянием, 
однако на каждом этапе создаются временные файлы для разбиения массива на две части. На обратной стадии выполнения 
временные файлы закрываются и удаляются. Для сортировки указывается файл с исходными данными и название файла для вывода

**Важно:** данную программу требуется выполнять из её директории, так как пути к файлам указаны отностительно директории исполнения

### JSON-парсер
Преобразователь основан на поле `__dict__`, которое содержат все пользовательские классы. 
Стандартные типы распознаются и записываются отдельно, используя метод `isinstance()`. Так же парсер записывает название класса под тэгом _"py/object"_,
что позваляет восстановить не только поля класса, но и даже сам объект. Для преобразования из _.json_ требуется так же
передать набор глобальных переменных командой `globals()`, что позволит парсеру создать объект необходимого класса.
Важными приимуществами является то, что парсер поддерживает вложенные объекты любых типов, поддерживает коллекции стандартных
и пользовательских типов.

Единствинным особым критерием для корректной работаспособности обратного преобразования является наличие в пользовательских
классах стандартного конструктора (в случае с _python_ это подразумеват наличие стандартных значений у всех аргументов 
конструктора)

### N-мерный вектор
Реализован путём переопределения операторов базового метакласса 'type' и содержит в себе все базовые операции, вроде
сложения, вычитания, умножения на константу и т.д. Его использование им довольно прямолинейно и не требует дополнительного
изучения своих методов. Поддерживает оператор `len()` для определения размерности и оператор сравнения `==`. Предусмотрены 
исключения по несповпадению размерностей векторов для тех операций, в которых она важна
В демо показаны основные методы класса и примеры их использования.

### Декоратор _@cached_
Схож по своей реализации с паттерном Singleton, однако в данном случае требуется хранить так же входные аргументы функции.
Декоратор является обёрткой для функции и в данном случае перед выполнением проверяет своё хранилище на наличие
результата выполнения функции с текущим набором аргументов. Само хранение проводится во вложенном словаре,
где первым ключом является название вызываемой функции, а вторым - строка со всеми входными аргументами.
При отсутствии результата выполнения функции с такими аргументами, необходимая функция выполняется и её выходные
данные сохраняется в нужном разделе словаря `func_cache`

### Singleton
Шаблон Одиночка реализован в виде метакласса 'SingletonTemplate', который требуется указать
в поле 'metaclass' при создании пользовательского класса. Действует он по стандартному принципу - 
сохраняет экземпляры классов при их создании, а при повторном создании возвращает уже сохранённый
экземпляр, независимо от места вызова конструктора
